module Main where

import System.IO
import System.Environment
import System.Exit

import Data.List
import Data.List.Split
import Data.Graph.Inductive.Graph
import Data.Graph.Inductive.Monad
import Data.Graph.Inductive.Monad.IOArray

import BellmanFord as BF

readEdgeListStr :: Read w => String -> String -> [LEdge w]
readEdgeListStr c str = map (f.splitOn c) $ lines str
    where f :: Read w => [String] -> (Node, Node, w)
          f [f,t,w] = (read f, read t, read w)
          f x = error $ "Could not parse line" ++ intercalate c x

generateUNodes :: Int -> [UNode]
generateUNodes n = zip [1..n] (repeat ())

readGraphEdgeList :: (GraphM m g, Read w) => String -> String -> m (g () w)
readGraphEdgeList del str = let el = readEdgeListStr del str in mkGraphM (generateUNodes $ maximum [max x y | (x,y,_) <- el]) el

showResultEdgeList :: Show w => [(Node, BFResultElem w)] -> String
showResultEdgeList = unlines . map f
    where f (n,(Just p,c)) = show n ++ " " ++ show p ++ " " ++ show c
          f (n,(Nothing,c)) = show n ++ " " ++ "s" ++ " " ++ show c

helpStr :: String -> String
helpStr bin = "Usage: " ++ bin ++ " [-f] [-p] [-s n] [delimiter] input output \n\
              \    -s n            uses n as source for the algorithm. By default n=1\n\
              \    -p              uses patricia trees instead of arrays as backend\n\
              \    -f              indicates that number should be treated as floats\n\
              \    [delimiter]     selects the delimiter character. Space by default\n\
              \\n\
              \    Files are a weighted edgelist as generated by Python Networkx"

parseArgs :: [String] -> IO ExitCode
parseArgs ("-s":n:xs) = parseArgs xs
parseArgs ("-f":xs) = parseArgs xs
parseArgs ("-p":xs) = parseArgs xs
parseArgs [input, output] = parseArgs [" ", input, output]
parseArgs [del, input, output] = do
    hi <- if input == "-" then return stdin else openFile input ReadMode
    ci <- hGetContents hi
    let gr = readGraphEdgeList del ci :: IO (SGr () Int)
    res <- BF.bellmanFordIO gr 1
    ho <- if output == "-" then return stdout else openFile output WriteMode
    hPutStrLn ho "# Time: TBD"
    hPutStr ho $ showResultEdgeList res
    hClose hi
    hClose ho
    return ExitSuccess
parseArgs _ = getProgName >>= putStrLn . helpStr >> return (ExitFailure 1)

main :: IO ()
main = getArgs >>= parseArgs >>= exitWith

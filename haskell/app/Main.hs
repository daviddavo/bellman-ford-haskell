{-# LANGUAGE FlexibleContexts #-}
module Main where

import System.IO
import System.CPUTime
import System.Environment
import System.Exit

import Control.Monad
import Control.DeepSeq
import Data.List
import Data.List.Split
import Data.Graph.Inductive.Graph
import Data.Graph.Inductive.Monad
import Data.Graph.Inductive.Monad.IOArray

import BellmanFord as BF
import BellmanFord.Monad as BF

parseLine :: Read w => String -> String -> LEdge w
parseLine c = f.splitOn c
    where f :: Read w => [String] -> (Node, Node, w)
          f [f,t,w] = (read f+1, read t+1, read w)
          f x = error $ "Could not parse line" ++ intercalate c x

readEdgeListStr :: Read w => String -> String -> [LEdge w]
readEdgeListStr c str = map (parseLine c) $ lines str

readEdgeListIO :: Read w => String -> Handle -> IO [LEdge w]
readEdgeListIO c h = do
    d <- hIsEOF h
    if d then return [] else do
        line <- hGetLine h
        el <- readEdgeListIO c h
        return (parseLine c line: el)

generateUNodes :: Int -> [UNode]
generateUNodes n = zip [1..n] (repeat ())

readGraphEdgeList :: (GraphM m g, Read w) => String -> String -> m (g () w)
readGraphEdgeList del str = let el = readEdgeListStr del str in mkGraphM (generateUNodes $ maximum [max x y | (x,y,_) <- el]) el

readGraphEdgeListFile :: (GraphM IO g, Read w) => String -> String -> IO (g () w)
readGraphEdgeListFile del file = do
    h <- if file == "-" then return stdin else openFile file ReadMode
    el <- readEdgeListIO del h
    hClose h
    mkGraphM (generateUNodes $ maximum [max x y | (x,y,_) <- el]) el

showResultEdgeList :: Show w => [(Node, BFResultElem w)] -> String
showResultEdgeList = unlines . map f
    where f (n,(Just p,c)) = show (n-1) ++ " " ++ show (p-1) ++ " " ++ show c
          f (n,(Nothing,c)) = show (n-1) ++ " " ++ "s" ++ " " ++ show c

helpStr :: String -> String
helpStr bin = "Usage: " ++ bin ++ " [-f] [-p] [-s n] [-d] input output \n\
              \    -s n            uses n as source for the algorithm. By default n=0\n\
              \    -p              uses patricia trees instead of arrays as backend\n\
              \    -f              indicates that numbers in edgelist are floats\n\
              \    -d              indicates the delimiter to be used. Space by default\n\
              \\n\
              \    Files are a weighted edgelist as generated by Python Networkx\n\
              \        starting from 0"

data Args = Args {
    source :: Int,
    delimiter :: String,
    floats :: Bool,
    patricia :: Bool
                 } deriving Show

defaultArgs :: Args
defaultArgs = Args { source=1, delimiter=" ", floats=False, patricia=False }

parseArgs :: Args -> [String] -> IO ExitCode
parseArgs args ("-s":n:xs) = parseArgs args { source=read n+1::Int } xs
parseArgs args ("-f":xs) = parseArgs args { floats=True } xs
parseArgs args ("-p":xs) = parseArgs args { patricia=True } xs
parseArgs args ("-d":d:xs) = parseArgs args { delimiter=d } xs
parseArgs args [input, output] = do
    hi <- if input == "-" then return stdin else openFile input ReadMode
    ti <- getCPUTime
    ci <- hGetContents hi
    let gr = readGraphEdgeList (delimiter args) ci :: IO (SGr () Int)
    res <- BF.bellmanFordIO gr (source args)
    ho <- if output == "-" then return stdout else openFile output WriteMode
    hPutStr ho $ showResultEdgeList res
    tf <- getCPUTime
    hPutStr ho "# t1: "
    hPrint ho ((fromIntegral (tf-ti)::Double)/10^12)
    hClose hi
    hClose ho
    return ExitSuccess
parseArgs args _ = getProgName >>= putStrLn . helpStr >> return (ExitFailure 1)

main :: IO ()
main = getArgs >>= parseArgs defaultArgs >>= exitWith

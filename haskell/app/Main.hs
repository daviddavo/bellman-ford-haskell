{-# LANGUAGE FlexibleContexts #-}
module Main where

import System.IO
import System.CPUTime
import System.Environment
import System.Exit

import Control.Monad
import Control.DeepSeq
import Data.List
import Data.List.Split
import Data.Graph.Inductive.Graph
import Data.Graph.Inductive.Monad
import Data.Graph.Inductive.Monad.IOArray

import BellmanFord as BF
import BellmanFord.Monad as BF

parseLine :: Read w => String -> String -> LEdge w
parseLine c = f.splitOn c
    where f :: Read w => [String] -> (Node, Node, w)
          f [f,t,w] = (read f+1, read t+1, read w)
          f x = error $ "Could not parse line" ++ intercalate c x

readEdgeListStr :: Read w => String -> String -> [LEdge w]
readEdgeListStr c str = map (parseLine c) $ lines str

generateUNodes :: Int -> [UNode]
generateUNodes n = zip [1..n] (repeat ())

readGraphEdgeList :: (GraphM m g, Read w) => String -> String -> m (g () w)
readGraphEdgeList del str = let el = readEdgeListStr del str in mkGraphM (generateUNodes $ maximum [max x y | (x,y,_) <- el]) el

showResultEdgeList :: Show w => [(Node, BFResultElem w)] -> String
showResultEdgeList = unlines . map f
    where f (n,(Just p,c)) = show (n-1) ++ " " ++ show (p-1) ++ " " ++ show c
          f (n,(Nothing,c)) = show (n-1) ++ " " ++ "s" ++ " " ++ show c

timeBFInt :: Handle -> Handle -> String -> Node -> IO ()
timeBFInt hi ho del s = do
    ci <- hGetContents hi
    let gr = readGraphEdgeList del ci :: IO (SGr () Int)
    ti <- getCPUTime
    res <- BF.bellmanFordIO gr s
    tf <- getCPUTime
    hPutStr ho $ showResultEdgeList res
    hPutStr ho "# t1: "
    hPrint ho ((fromIntegral (tf-ti)::Double)/10^12)

timeBFFloat :: Handle -> Handle -> String -> Node -> IO ()
timeBFFloat hi ho del s = do
    ci <- hGetContents hi
    let gr = readGraphEdgeList del ci :: IO (SGr () Float)
    ti <- getCPUTime
    res <- BF.bellmanFordIO gr s
    tf <- getCPUTime
    hPutStr ho $ showResultEdgeList res
    hPutStr ho "# t1: "
    hPrint ho ((fromIntegral (tf-ti)::Double)/10^12)


helpStr :: String -> String
helpStr bin = "Usage: " ++ bin ++ " [-f] [-p] [-s n] [-d] input output \n\
              \    -s n            uses n as source for the algorithm. By default n=0\n\
              \    -f              indicates that numbers in edgelist are floats\n\
              \    -d              indicates the delimiter to be used. Space by default\n\
              \\n\
              \    Files are a weighted edgelist as generated by Python Networkx\n\
              \        starting from 0"

data Args = Args {
    source :: Int,
    delimiter :: String,
    floats :: Bool,
    patricia :: Bool
                 } deriving Show

defaultArgs :: Args
defaultArgs = Args { source=1, delimiter=" ", floats=False, patricia=False }

parseArgs :: Args -> [String] -> IO ExitCode
parseArgs args ("-s":n:xs) = parseArgs args { source=read n+1::Int } xs
parseArgs args ("-f":xs) = parseArgs args { floats=True } xs
parseArgs args ("-p":xs) = parseArgs args { patricia=True } xs
parseArgs args ("-d":d:xs) = parseArgs args { delimiter=d } xs
parseArgs args [input, output] = do
    hi <- if input == "-" then return stdin else openFile input ReadMode
    ho <- if output == "-" then return stdout else openFile output WriteMode
    let tbf = if floats args then timeBFInt else timeBFFloat
    tbf hi ho (delimiter args) (source args)
    hClose hi
    hClose ho
    return ExitSuccess
parseArgs args _ = getProgName >>= putStrLn . helpStr >> return (ExitFailure 1)

main :: IO ()
main = getArgs >>= parseArgs defaultArgs >>= exitWith
